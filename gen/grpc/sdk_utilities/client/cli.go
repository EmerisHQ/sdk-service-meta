// Code generated by goa v3.7.5, DO NOT EDIT.
//
// sdk-utilities gRPC client CLI support package
//
// Command:
// $ goa gen github.com/emerishq/sdk-service-meta

package client

import (
	"encoding/json"
	"fmt"

	sdk_utilitiespb "github.com/emerishq/sdk-service-meta/gen/grpc/sdk_utilities/pb"
	sdkutilities "github.com/emerishq/sdk-service-meta/gen/sdk_utilities"
)

// BuildAccountNumbersPayload builds the payload for the sdk-utilities
// accountNumbers endpoint from CLI flags.
func BuildAccountNumbersPayload(sdkUtilitiesAccountNumbersMessage string) (*sdkutilities.AccountNumbersPayload, error) {
	var err error
	var message sdk_utilitiespb.AccountNumbersRequest
	{
		if sdkUtilitiesAccountNumbersMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesAccountNumbersMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addresHex\": \"Autem fugiat optio.\",\n      \"bech32Prefix\": \"Et quo dolorum.\",\n      \"chainName\": \"Ea eaque.\",\n      \"port\": 3852088934630280001\n   }'")
			}
		}
	}
	v := &sdkutilities.AccountNumbersPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}
	if message.Bech32Prefix != "" {
		v.Bech32Prefix = &message.Bech32Prefix
	}
	if message.AddresHex != "" {
		v.AddresHex = &message.AddresHex
	}

	return v, nil
}

// BuildSupplyPayload builds the payload for the sdk-utilities supply endpoint
// from CLI flags.
func BuildSupplyPayload(sdkUtilitiesSupplyMessage string) (*sdkutilities.SupplyPayload, error) {
	var err error
	var message sdk_utilitiespb.SupplyRequest
	{
		if sdkUtilitiesSupplyMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesSupplyMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Amet nostrum sed est nihil error odit.\",\n      \"paginationKey\": \"Eos maxime esse nulla quis blanditiis aspernatur.\",\n      \"port\": 3640771888125048896\n   }'")
			}
		}
	}
	v := &sdkutilities.SupplyPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}
	if message.PaginationKey != "" {
		v.PaginationKey = &message.PaginationKey
	}

	return v, nil
}

// BuildSupplyDenomPayload builds the payload for the sdk-utilities supplyDenom
// endpoint from CLI flags.
func BuildSupplyDenomPayload(sdkUtilitiesSupplyDenomMessage string) (*sdkutilities.SupplyDenomPayload, error) {
	var err error
	var message sdk_utilitiespb.SupplyDenomRequest
	{
		if sdkUtilitiesSupplyDenomMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesSupplyDenomMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Hic eum nostrum quia ut reiciendis ratione.\",\n      \"denom\": \"Tempore alias quo animi eos.\",\n      \"port\": 382605817140914569\n   }'")
			}
		}
	}
	v := &sdkutilities.SupplyDenomPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}
	if message.Denom != "" {
		v.Denom = &message.Denom
	}

	return v, nil
}

// BuildQueryTxPayload builds the payload for the sdk-utilities queryTx
// endpoint from CLI flags.
func BuildQueryTxPayload(sdkUtilitiesQueryTxMessage string) (*sdkutilities.QueryTxPayload, error) {
	var err error
	var message sdk_utilitiespb.QueryTxRequest
	{
		if sdkUtilitiesQueryTxMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesQueryTxMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Velit occaecati ut.\",\n      \"hash\": \"Qui ut sequi animi vero eaque.\",\n      \"port\": 1410794041151114724\n   }'")
			}
		}
	}
	v := &sdkutilities.QueryTxPayload{
		ChainName: message.ChainName,
		Hash:      message.Hash,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildBroadcastTxPayload builds the payload for the sdk-utilities broadcastTx
// endpoint from CLI flags.
func BuildBroadcastTxPayload(sdkUtilitiesBroadcastTxMessage string) (*sdkutilities.BroadcastTxPayload, error) {
	var err error
	var message sdk_utilitiespb.BroadcastTxRequest
	{
		if sdkUtilitiesBroadcastTxMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesBroadcastTxMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Ut voluptas aut excepturi.\",\n      \"port\": 5921602754859307309,\n      \"txBytes\": \"RnVnYSBibGFuZGl0aWlzIHBsYWNlYXQgaXVyZSBleGVyY2l0YXRpb25lbSBpdXN0by4=\"\n   }'")
			}
		}
	}
	v := &sdkutilities.BroadcastTxPayload{
		ChainName: message.ChainName,
		TxBytes:   message.TxBytes,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildTxMetadataPayload builds the payload for the sdk-utilities txMetadata
// endpoint from CLI flags.
func BuildTxMetadataPayload(sdkUtilitiesTxMetadataMessage string) (*sdkutilities.TxMetadataPayload, error) {
	var err error
	var message sdk_utilitiespb.TxMetadataRequest
	{
		if sdkUtilitiesTxMetadataMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesTxMetadataMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"txBytes\": \"UXVpZGVtIG1vbGVzdGlhZSBjdW1xdWUgc3VudCBkb2xvcmVtLg==\"\n   }'")
			}
		}
	}
	v := &sdkutilities.TxMetadataPayload{
		TxBytes: message.TxBytes,
	}

	return v, nil
}

// BuildBlockPayload builds the payload for the sdk-utilities block endpoint
// from CLI flags.
func BuildBlockPayload(sdkUtilitiesBlockMessage string) (*sdkutilities.BlockPayload, error) {
	var err error
	var message sdk_utilitiespb.BlockRequest
	{
		if sdkUtilitiesBlockMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesBlockMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Non sit sunt excepturi ullam delectus corrupti.\",\n      \"height\": 8894233288527025489,\n      \"port\": 4031148209971103528\n   }'")
			}
		}
	}
	v := &sdkutilities.BlockPayload{
		ChainName: message.ChainName,
		Height:    message.Height,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildLiquidityParamsPayload builds the payload for the sdk-utilities
// liquidityParams endpoint from CLI flags.
func BuildLiquidityParamsPayload(sdkUtilitiesLiquidityParamsMessage string) (*sdkutilities.LiquidityParamsPayload, error) {
	var err error
	var message sdk_utilitiespb.LiquidityParamsRequest
	{
		if sdkUtilitiesLiquidityParamsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesLiquidityParamsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Nobis magnam tenetur.\",\n      \"port\": 8010145524969550654\n   }'")
			}
		}
	}
	v := &sdkutilities.LiquidityParamsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildLiquidityPoolsPayload builds the payload for the sdk-utilities
// liquidityPools endpoint from CLI flags.
func BuildLiquidityPoolsPayload(sdkUtilitiesLiquidityPoolsMessage string) (*sdkutilities.LiquidityPoolsPayload, error) {
	var err error
	var message sdk_utilitiespb.LiquidityPoolsRequest
	{
		if sdkUtilitiesLiquidityPoolsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesLiquidityPoolsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Dolorem voluptatem dignissimos nam suscipit autem.\",\n      \"port\": 2954009122666477961\n   }'")
			}
		}
	}
	v := &sdkutilities.LiquidityPoolsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildMintInflationPayload builds the payload for the sdk-utilities
// mintInflation endpoint from CLI flags.
func BuildMintInflationPayload(sdkUtilitiesMintInflationMessage string) (*sdkutilities.MintInflationPayload, error) {
	var err error
	var message sdk_utilitiespb.MintInflationRequest
	{
		if sdkUtilitiesMintInflationMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesMintInflationMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Consequatur laborum aperiam et.\",\n      \"port\": 4404881313969695921\n   }'")
			}
		}
	}
	v := &sdkutilities.MintInflationPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildMintParamsPayload builds the payload for the sdk-utilities mintParams
// endpoint from CLI flags.
func BuildMintParamsPayload(sdkUtilitiesMintParamsMessage string) (*sdkutilities.MintParamsPayload, error) {
	var err error
	var message sdk_utilitiespb.MintParamsRequest
	{
		if sdkUtilitiesMintParamsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesMintParamsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Nihil voluptatem.\",\n      \"port\": 5396156918032315178\n   }'")
			}
		}
	}
	v := &sdkutilities.MintParamsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildMintAnnualProvisionPayload builds the payload for the sdk-utilities
// mintAnnualProvision endpoint from CLI flags.
func BuildMintAnnualProvisionPayload(sdkUtilitiesMintAnnualProvisionMessage string) (*sdkutilities.MintAnnualProvisionPayload, error) {
	var err error
	var message sdk_utilitiespb.MintAnnualProvisionRequest
	{
		if sdkUtilitiesMintAnnualProvisionMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesMintAnnualProvisionMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Ipsam assumenda perferendis.\",\n      \"port\": 5815409125182454944\n   }'")
			}
		}
	}
	v := &sdkutilities.MintAnnualProvisionPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildMintEpochProvisionsPayload builds the payload for the sdk-utilities
// mintEpochProvisions endpoint from CLI flags.
func BuildMintEpochProvisionsPayload(sdkUtilitiesMintEpochProvisionsMessage string) (*sdkutilities.MintEpochProvisionsPayload, error) {
	var err error
	var message sdk_utilitiespb.MintEpochProvisionsRequest
	{
		if sdkUtilitiesMintEpochProvisionsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesMintEpochProvisionsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Commodi vel.\",\n      \"port\": 1645460152882063013\n   }'")
			}
		}
	}
	v := &sdkutilities.MintEpochProvisionsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildDelegatorRewardsPayload builds the payload for the sdk-utilities
// delegatorRewards endpoint from CLI flags.
func BuildDelegatorRewardsPayload(sdkUtilitiesDelegatorRewardsMessage string) (*sdkutilities.DelegatorRewardsPayload, error) {
	var err error
	var message sdk_utilitiespb.DelegatorRewardsRequest
	{
		if sdkUtilitiesDelegatorRewardsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesDelegatorRewardsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addresHex\": \"Vero quis.\",\n      \"bech32Prefix\": \"Minima eligendi itaque.\",\n      \"chainName\": \"Et expedita quibusdam.\",\n      \"port\": 7735830947852742027\n   }'")
			}
		}
	}
	v := &sdkutilities.DelegatorRewardsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}
	if message.Bech32Prefix != "" {
		v.Bech32Prefix = &message.Bech32Prefix
	}
	if message.AddresHex != "" {
		v.AddresHex = &message.AddresHex
	}

	return v, nil
}

// BuildEstimateFeesPayload builds the payload for the sdk-utilities
// estimateFees endpoint from CLI flags.
func BuildEstimateFeesPayload(sdkUtilitiesEstimateFeesMessage string) (*sdkutilities.EstimateFeesPayload, error) {
	var err error
	var message sdk_utilitiespb.EstimateFeesRequest
	{
		if sdkUtilitiesEstimateFeesMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesEstimateFeesMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Rerum est vel.\",\n      \"port\": 5512773892388447471,\n      \"txBytes\": \"UXVvZCB2b2x1cHRhdHVtIHN1bnQgdmVuaWFtIG5vbi4=\"\n   }'")
			}
		}
	}
	v := &sdkutilities.EstimateFeesPayload{
		ChainName: message.ChainName,
		TxBytes:   message.TxBytes,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildStakingParamsPayload builds the payload for the sdk-utilities
// stakingParams endpoint from CLI flags.
func BuildStakingParamsPayload(sdkUtilitiesStakingParamsMessage string) (*sdkutilities.StakingParamsPayload, error) {
	var err error
	var message sdk_utilitiespb.StakingParamsRequest
	{
		if sdkUtilitiesStakingParamsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesStakingParamsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Aut consequatur sequi eveniet nisi aut.\",\n      \"port\": 422519322067561036\n   }'")
			}
		}
	}
	v := &sdkutilities.StakingParamsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildStakingPoolPayload builds the payload for the sdk-utilities stakingPool
// endpoint from CLI flags.
func BuildStakingPoolPayload(sdkUtilitiesStakingPoolMessage string) (*sdkutilities.StakingPoolPayload, error) {
	var err error
	var message sdk_utilitiespb.StakingPoolRequest
	{
		if sdkUtilitiesStakingPoolMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesStakingPoolMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Sint numquam dolore et nemo quia quia.\",\n      \"port\": 1379536919246739616\n   }'")
			}
		}
	}
	v := &sdkutilities.StakingPoolPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildEmoneyInflationPayload builds the payload for the sdk-utilities
// emoneyInflation endpoint from CLI flags.
func BuildEmoneyInflationPayload(sdkUtilitiesEmoneyInflationMessage string) (*sdkutilities.EmoneyInflationPayload, error) {
	var err error
	var message sdk_utilitiespb.EmoneyInflationRequest
	{
		if sdkUtilitiesEmoneyInflationMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesEmoneyInflationMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Officiis quo aperiam sed aut.\",\n      \"port\": 3236519200905233883\n   }'")
			}
		}
	}
	v := &sdkutilities.EmoneyInflationPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildBudgetParamsPayload builds the payload for the sdk-utilities
// budgetParams endpoint from CLI flags.
func BuildBudgetParamsPayload(sdkUtilitiesBudgetParamsMessage string) (*sdkutilities.BudgetParamsPayload, error) {
	var err error
	var message sdk_utilitiespb.BudgetParamsRequest
	{
		if sdkUtilitiesBudgetParamsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesBudgetParamsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Nesciunt laboriosam quia et ratione rerum nihil.\",\n      \"port\": 2751582522214065040\n   }'")
			}
		}
	}
	v := &sdkutilities.BudgetParamsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildDistributionParamsPayload builds the payload for the sdk-utilities
// distributionParams endpoint from CLI flags.
func BuildDistributionParamsPayload(sdkUtilitiesDistributionParamsMessage string) (*sdkutilities.DistributionParamsPayload, error) {
	var err error
	var message sdk_utilitiespb.DistributionParamsRequest
	{
		if sdkUtilitiesDistributionParamsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesDistributionParamsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Autem impedit quae excepturi vel quod corporis.\",\n      \"port\": 7190931602230024663\n   }'")
			}
		}
	}
	v := &sdkutilities.DistributionParamsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildOsmoPoolsPayload builds the payload for the sdk-utilities osmoPools
// endpoint from CLI flags.
func BuildOsmoPoolsPayload(sdkUtilitiesOsmoPoolsMessage string) (*sdkutilities.OsmoPoolsPayload, error) {
	var err error
	var message sdk_utilitiespb.OsmoPoolsRequest
	{
		if sdkUtilitiesOsmoPoolsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesOsmoPoolsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Suscipit sequi exercitationem.\",\n      \"port\": 4611927448828070193\n   }'")
			}
		}
	}
	v := &sdkutilities.OsmoPoolsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}

// BuildCrescentPoolsPayload builds the payload for the sdk-utilities
// crescentPools endpoint from CLI flags.
func BuildCrescentPoolsPayload(sdkUtilitiesCrescentPoolsMessage string) (*sdkutilities.CrescentPoolsPayload, error) {
	var err error
	var message sdk_utilitiespb.CrescentPoolsRequest
	{
		if sdkUtilitiesCrescentPoolsMessage != "" {
			err = json.Unmarshal([]byte(sdkUtilitiesCrescentPoolsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"chainName\": \"Quia atque id est expedita rerum.\",\n      \"port\": 588797028473812858\n   }'")
			}
		}
	}
	v := &sdkutilities.CrescentPoolsPayload{
		ChainName: message.ChainName,
	}
	if message.Port != 0 {
		portptr := int(message.Port)
		v.Port = &portptr
	}

	return v, nil
}
